---
title: "Normalization and Transformation of scRNA-Seq Counts"
output:
  md_document:
    variant: markdown_github
    toc: true
  html_document:
    toc: true
    toc_float: true
---

```{r prereqs}
knitr::opts_chunk$set(echo = T, message = FALSE, warning = FALSE)
stdt<-date()

# Libraries
library(tidyverse)
library(Seurat)
library(cowplot)
library(kableExtra)
```


**Goal of this workshop:** Learn how to load cellranger output into R and prepare QC'd data for downstream analyses

**What's covered in this workshop:** - Load data into R as a Seurat object - Verify that the data have been QC'd - Transform gene counts

**Data source:** Christian et al. 2021 Cell Reports (<https://doi.org/10.1016/j.celrep.2021.109118>)

Note that the Seurat - Guided Clustering Tutorial (<https://satijalab.org/seurat/articles/pbmc3k_tutorial.html>) includes a lot of overlapping information.

**METHOD DETAILS, Single-cell RNA-seq analysis, page e4**

-   Pre-processing: "Raw short reads were demultiplexed, filtering and mapped to 
mouse genome GRCm38/mm10 using cellranger v2.02."

-   QC: "The gene count matrices from cellranger were subjected to quality 
control, pre-processing and clustering using the R Seurat 2.3.4 package 
(Butler et al., 2018). Low-quality cells that had less than 200 expressed genes 
and more than 5% mitochondrial genes were filtered out."

-   Analysis: "Gene counts were scaled to total gene expression and percentage 
of mitochondrial genes with a scaling factor of 10,000, and then 
log-transformed. The high dimensional data for each sample were reduced by PCA 
and t-Distributed Stochastics Neighbor Embedding (tSNE). 
We used the FindCluster function to group clusters in each sample 
with a resolution of 0.6. Differential expressed genes (DEGs) were 
identified using the Wilcoxon rank-sum test."

## 1. Load data into R as Seurat objects


First, we identify the hdf5 (*.h5) files containing the UMI counts from
cellranger from the Christian et al. 2021 paper, and create a 
manifest including file and sample
ids and the md5 hash. Review the R list.files(), basename() and gsub() 
functions before reviwieng this code chunk.


```{r datafiles}
# Set data directory path
datadir <- "/hpc/group/chsi-mic-2022/data/Christian2021CellReports/"
# Get all files with ,h5 extension
h5files <- list.files(path = datadir, pattern = ".h5", full.names = TRUE)
# Inspect inventory
tibble::tibble(
  fname = basename(h5files),
  sampid =  gsub("_10x.h5", "", fname),
  md5 = tools::md5sum(h5files)
) -> manifest
manifest
```


Confirm that you have identified data files corresponding 
(see Fig 2A of Christian et al. for tSNE plots of each sample type):

-   Tem = effector memory in tumor
-   Tcm = central memory in tumor
-   Trm = resident memory in tumor
-   disTrm = resident memory T-cells outside of the tumor


Next, we write a function to import the hdf5 files as
Seurat objects. Review the Read10X_h5() and CreateSeuratObject()
functions from the Seurat package and the file.path() and paste0() functions
from R before reviewing this code chunk.

```{r importfun}
readin_10x_to_SO <- function(datadir, fname, sampid, min.cells = 0, min.genes = 0){
  # Create a full file name
  filename <- file.path(datadir, paste0(sampid, "_10x.h5"))
  Read10X_h5(filename) %>%
    CreateSeuratObject(
      project = sampid, 
      min.cells = min.cells, 
      min.genes = min.genes) -> seu.obj
  return(seu.obj)
}
```

Next, we use our custom function to read in the hdf5 files. This step will 
create a list of four Seurat objects by looping over the rows of the manifest
data frame. Review list and dataframe R objects and how to extract information
from these, and the R seq_len() function before reviewing this code chunk. Note
that the number of genes and cells vary across the files.

```{r importh5}
seulist <- list()
for(i in seq_len(nrow(manifest))){
  fname <- manifest[[i,"fname"]]
  sampid <- manifest[[i,"sampid"]]
  seulist[[i]] <- readin_10x_to_SO(datadir, fname, sampid)
  names(seulist)[i] <- sampid
}
seulist
```
The following illustrates how to access a specific object from the list you have created

```{r listaccessex}
seulist[["Tem"]]
```



## 2. Review the imported data against the information provided in the Christian paper

*METHOD DETAILS, Single-cell RNA-seq analysis, page e4*: "Low-quality cells that 
had less than 200 expressed genes and more than 5% mitochondrial genes were filtered out."

First, we inspect the count matrix from on the imported objects. We observe that
gene symbols are used as feature names

```{r inspectcntmat}
tem <- seulist$Tem
cntmat <- tem@assays$RNA@counts
head(cntmat[1:20,1:20])
#rownames(curr.count)[1:10]
#rownames(curr.count)[grepl("^mt-", rownames(curr.count))] # these look like mitochondrial genes!
```

Next, we add the mitochondrial percentage to each Seurat objects in our list
(see QC notebook for details).
We consider to equivalent approaches (looping and lapply) for updating
Seurat objects in a list.
First, we define a function which augments
the meta data of a Seurat object by the mitochondrial proportion.


```{r addmtfun}
addmt <- function(so){
  so[["percent.mt"]] <- PercentageFeatureSet(so, pattern = "^mt-")
  return(so)
}
```

Next we apply this function by looping over the list.

```{r addmtloop}
seulist.mt <- list()
for(i in 1:length(seulist)){
  seulist.mt[[i]] <- add_mt(seulist[[i]])
}
names(seulist.mt) <- names(seulist)
seulist.mt
```

Generally speaking the preferred approach to applying functions to a list
of Seurat objects is to use the R lapply() function.

```{r}
seulist <- lapply(seulist, add_mt)
seulist
```


Next, we examine the distribution of nFeature and nCount for each dataset

```{r plotfun1}
plotfun1 <- function(so) {
  so@meta.data %>% 
    ggplot(aes(x = nCount_RNA, y = nFeature_RNA, color = percent.mt)) +
    geom_point(size = 1) +
    labs(x = "nCount", y = "nFeature", color = "MT%") +
    theme_classic() +
    geom_hline(yintercept = 200, linetype = 2) +
    ggtitle(so@project.name)
}
```

This function can be used to produce the plot for a single object.
```{r plotfun1ex}
plotfun1(seulist[["Tem"]])
```
The function can also be applied to all Seurat objects in the list.

```{r plotfun1apply}
lapply(seulist, plotfun1)
```


Are there any cells with less than 200 expressed genes?


Summarize as a table

```{r}
df <- data.frame(seuobj = names(seulist))
df[,c("min","mean","max")] <- NA
for (i in 1:length(seulist)){
  df[i,c("min","mean","max")] <- seulist[[i]]@meta.data %>%
    summarize(min = min(nFeature_RNA),
            mean = mean(nFeature_RNA),
            max = max(nFeature_RNA))
  
}
df
```

An alternative way to do this is by using purrr mapping functions

```{r}
seulist %>%
  map_dfr(~.x@meta.data, .id = "seuobj") %>%
  group_by(seuobj) %>%
  summarize(min = min(nFeature_RNA),
            mean = mean(nFeature_RNA),
            max = max(nFeature_RNA))
```

Are there any cells with more than 5% mitochondrial genes?

We first write a function to produce a figure

```{r plotfun2}
plotfun2 <- function(so) {
  so@meta.data %>%
    ggplot(aes(x = percent.mt)) +
    geom_histogram() +
    theme_classic() +
    geom_vline(xintercept = 5, linetype = 2) +
    ggtitle(so@project.name)
}
```
```{r}
lapply(seulist, plotfun2)
```

Summarize as a table

```{r}
df <- data.frame(seuobj = names(seulist))
df[,c("min","mean","max")] <- NA
for (i in 1:length(seulist)){
  df[i,c("min","mean","max")] <- seulist[[i]]@meta.data %>%
    summarize(min = min(percent.mt),
            mean = mean(percent.mt),
            max = max(percent.mt))
  
}
df
```

## 3. Transform gene counts

*METHOD DETAILS, Single-cell RNA-seq analysis, page e4*: "Gene counts were 
scaled to total gene expression and percentage of mitochondrial genes with a 
scaling factor of 10,000, and then log-transformed."

We will examine the structure of a Seurat object. First, we get a list of
the slots

```{r slotnames}
tem <- seulist$Tem
slotNames(tem)
```
The object has a single assay

```{r assay}
tem@assays
```
It is also the "active" assay
```{r activeassay}
tem@active.assay
```
Now let's look at the slots of the RNA assay

```{r RNAslot}
slotNames(tem@assays$RNA)
```
This will extract the count matrix

```{r RNAslot}
tem@assays$RNA@counts[1:10,1:10]
```

Note that the data slot is identical to the counts slot

```{r RNAslot}
identical(tem@assays$RNA@data, tem@assays$RNA@counts)
```
The scale.data slot is empty (the count have not yet been scaled)

```{r RNAslot}
tem@assays$RNA@scale.data
```


### Normalize the counts and re-examine the data slots. Note that only the values in the "data" slot have changed.

```{r}
tem.s <- NormalizeData(object = tem, normalization.method = "LogNormalize", scale.factor = 10000)

s.counts <- tem.s@assays$RNA@counts
dim(s.counts) # 12571 features as rows and 1457 cells as columns
s.counts[1:10,1:10]
#colnames(s.counts)[1:10]
#rownames(s.counts)[1:10]

s.data <- tem.s@assays$RNA@data
dim(s.data) # 12571 features as rows and 1457 cells as columns
s.data[1:10,1:10]
#colnames(s.data)[1:10]
#rownames(s.data)[1:10]

s.scale.data <- tem.s@assays$RNA@scale.data
dim(s.scale.data) # empty

## plot
i <- 1
colnames(s.counts)[i] # cell identifier
df <- data.frame(count = s.counts[,i], data = s.data[,i], feature = row.names(s.counts), row.names = NULL)
ggplot(df, aes(x = count, y = data)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 0, linetype = 2, color = "grey")
```

### Normalize each of the Seurat objects in the list



```{r normalize}
normfun1 <- function(so) {
   NormalizeData(
     so, 
     normalization.method = "LogNormalize", 
    scale.factor = 10000
    )
}
seulist <- lapply(seulist, normfun1)
```
```{r}

sampleNames <- names(seulist)
seulist.n <- list()
for(i in 1:length(sampleNames)){
  seulist.n[[i]] <- NormalizeData(object = seulist[[i]], normalization.method = "LogNormalize", 
                                  scale.factor = 10000)
}
names(seulist.n) <- sampleNames
```

### Save the list of normalized Seurat objects

```{r}
newfile <- file.path(intermeddir, "seulist-n.rds")
#saveRDS(seulist.n, file = newfile)

tools::md5sum(newfile)
```


One an use the summarize() function from the dplyr function to produce summary statistics
for the meta data. The following is a simple demonstration.

```{r summ1}
seulist[["Tem"]]@meta.data %>% 
  summarize(
    n=n(), 
    min=min(nCount_RNA), 
    mean=mean(nCount_RNA), 
    median=median(nCount_RNA),
    max = max(nCount_RNA)
  ) %>% 
  mutate(dlabel = "Tem", .before = "n")

```

To generalize, we can consider the following function

```{r summ2}
summfun1 <- function(so) {
  so@meta.data %>% 
    summarize(
    n=n(), 
    min=min(nCount_RNA), 
    mean=mean(nCount_RNA), 
    median=median(nCount_RNA),
    max = max(nCount_RNA)
  ) %>% 
  mutate(dlabel = so@project.name, .before = "n")
}

summfun1(seulist[["Tem"]])
```

To generalize this further so as to not hardcode the
meta data column. Note the use of the !!sym() function
to programmatically pass the variable name

```{r summ3}
summfun2 <- function(so, mdcol) {
  so@meta.data %>% 
    summarize(
    n=n(), 
    min=min(!!(sym(mdcol))), 
    mean=mean(!!sym(mdcol)),
    median=median(!!sym(mdcol)),
    max = max(!!sym(mdcol))
  ) %>% 
  mutate(dlabel = so@project.name, mfeat = mdcol, .before = "n")
}
```

Now apply this function.

```{r summ4}
summfun2(seulist[["Tem"]], "nCount_RNA")
summfun2(seulist[["Tem"]], "nFeature_RNA")
summfun2(seulist[["Tem"]], "percent.mt")
```

```{r summ4}
do.call("rbind", lapply(seulist, summfun2, mdcol = "percent.mt"))
```



```{r}
a %>% mutate(b="a", .before = "n")
```
```{r}
lapply(seulist, function())
seulist[["Tem"]]@meta.data %>% 
  summarize(
    n=n(), 
    min=min(nCount_RNA), 
    mean=mean(nCount_RNA), 
    median=median(nCount_RNA)
  )
```




