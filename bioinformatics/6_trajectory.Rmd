---
title: "Trajectory analysis with monocle"
output:
  md_document:
    variant: markdown_github
    toc: true
  html_document:
    toc: true
    toc_float: true
---
```{r prereqs}
knitr::opts_chunk$set(echo = T, message = FALSE, warning = FALSE)
stdt <- date()

# Libraries
library(tidyverse)
library(Seurat)
library(monocle); package.version("monocle")

# Paths
wd <- "/hpc/group/chsi-mic-2022"
intermeddir <- file.path(wd, "intermed")
outdir <- file.path("/work",Sys.info()[["user"]],"output")
#outdir
```

**Goal of this workshop:** Learn to analyze cell trajectories with monocle

**What's covered in this workshop:**

- Merge Seurat objects
- Create a Monocle object
- Run trajectory analysis
- Test for DE over pseudotime

**Data source:** Christian et al. 2021 Cell Reports (https://doi.org/10.1016/j.celrep.2021.109118)

**METHOD DETAILS, Single-cell RNA-seq analysis, page e4**
- Analysis: "To infer the lineage development of TEFF / EM to TCM, we used Monocle package v2.5.4 (Qiu et al., 2017). The top 2000 significant DEGs were chosen to order genes for trajectory reconstruction using the DDRTree method followed by dimension reduction, cell trajectory inference and pseudo-time measurements, which were computed via reversed graph embedding."

## Load data

Load Seurat objects into R

```{r}
seulist <- readRDS(file.path(intermeddir, "seulist_drc.rds"))

trm <- seulist[["Trm"]]
disttrm <- seulist[["disTrm"]]
tem <- seulist[["Tem"]]
```

## 1. Merge Seurat objects

Merge the seurat objects together so that there is 1 object that includes all samples.

Since we will be merging the cells, it is useful to add a prefix to the cell names that identify which sample the cell came from. This information can also be stored in the metadata.

```{r}
Cells(trm)[1:10]
trm.rn <- RenameCells(trm, add.cell.id = 'Trm')
Cells(trm.rn)[1:10]

# do this for the remaining samples that will be merged
tem.rn <- RenameCells(tem, add.cell.id='Tem')
disttrm.rn <- RenameCells(disttrm, add.cell.id='MucosalTrm')
```

Merge Trm and MucosalTrm cells
```{r}
comb <- merge(trm.rn, disttrm.rn)

comb@meta.data %>%
  group_by(orig.ident) %>%
  summarize(ncells = length(orig.ident))
```
Add the Tem cells
```{r}
comb <- merge(comb, tem.rn)

comb@meta.data %>%
  group_by(orig.ident) %>%
  summarize(ncells = length(orig.ident))
```
Check the cell names
```{r}
dim(comb@meta.data) #2779 cells in total

Cells(comb) %>%
  str_split("_") %>%
  map_dfr(~data.frame(prefix = .x[1], orig.cellname = .x[2])) %>%
  mutate(new.cellname = Cells(comb)) -> cellname.df

cellname.df %>%
  group_by(prefix) %>%
  summarize(ncells = length(orig.cellname))
```

## 2. Create a Monocle object

Monocle uses a different type of object, a "CellDataSet" object, to store single-cell data. There are three data elements to a CellDataSet object:

- **cellData**: expression matrix with rows as genes and columns as cells
- **phenoData**: data frame containing attributes of individual cells
- **featureData**: data frame containing attributes of gene features

Extract the count matrix with rows as genes and columns as cells.
```{r}
cd <- comb@assays$RNA@counts
dim(cd)
rownames(cd)[1:5]
colnames(cd)[1:5]
```

Extract the cell-level data.
```{r}
pd <- comb@meta.data
dim(pd)
rownames(pd)[1:5]
```

Extract the gene-level metadata.
```{r}
rownames(comb)[1:5]
fd <- data.frame(gene_short_name = rownames(comb), 
                 row.names = rownames(comb))
dim(fd)
row.names(fd)[1:5]
```

Create the CellDataSet object.
```{r}
pd.adf <- new("AnnotatedDataFrame", data = pd)
fd.adf <- new("AnnotatedDataFrame", data = fd)

cds <- newCellDataSet(cellData = cd, 
                      phenoData = pd.adf, 
                      featureData = fd.adf)
```

## 3. Run tranjectory analysis

Before running the trajectory analysis, the counts need to be preprocessed in the following ways.

Estimate size factors. **Size factor corresponds with cell library size? Is this similar to how size factors estimated for bulk DE in DESeq? Add info?** Notice that the estimateSizeFactors() function calculates a size factor for each cell and populates the column `Size_Factor` in the phenoData dataframe.
```{r}
cds.es <- estimateSizeFactors(cds)
head(pData(cds))
head(pData(cds.es))
```

Estimate dispersions **Add info about the purpose of this step ** Notice that the estimated dispersion data can be extracted from the CellDataSet object using the function dispersionTable().
```{r}
cds.ds <- estimateDispersions(cds.es)

#head(dispersionTable(cds.es)) # if you haven't already estimated the dispersion, this will throw an error
head(dispersionTable(cds.ds))
```

Filter out genes with low expression. 

Notice that the detectGenes() function sets the expression detection threshold, calculates the number of cells that express each gene above that threshold, and adds that value to the feature dataframe.
```{r}
head(fData(cds.ds))
cds.filt <- detectGenes(cds.ds, min_expr = 0.1) # set the detection threshold to 0.1
head(fData(cds.filt))
```

Identify genes that are expressed in at least 100 cells. These genes will be retained.
```{r}
dim(fData(cds.filt))[1] # 13009 features in total
fData(cds.filt) %>%
  filter(num_cells_expressed >= 100) %>%
  row.names() -> expressed_genes
expressed_genes[1:5]
length(expressed_genes) # 6543 features that are expressed in at least 100 cells
```

Select genes
```{r}
cds.filt # assayData: 13009 features, 2779 samples
cds.exprs <- cds.filt[expressed_genes,] 
cds.exprs # assayData: 6543 features, 2779 samples 
```

Test if genes are differentially expressed based on sample type **Note that I changed this to run using 2 cores because I think that is what was requested by default for the workspace**
```{r}
unique(pData(cds.exprs)$orig.ident)
#diff_test_res <- differentialGeneTest(cds.exprs, fullModelFormulaStr = "~orig.ident", cores = 2)
# since this can take some time, I saved the resulting object `diff_test_res` as an intermediate
#saveRDS(diff_test_res, file.path(intermeddir, "diff_test_res.RData"))

diff_test_res <- readRDS(file.path(intermeddir, "diff_test_res.RData"))
```

Examine DE results table. Tested genes are shown in the rows. Columns include...

- **status**: What does "OK" mean?
- **family**: What does "negbinomial.size" mean?
- **pval** : p value associated with gene
- **qval**: q value, aka adjusted p value?
- **gene_short_name** : Should match rownames
- **num_cells_expressed** : Should match values in fData

```{r}
dim(diff_test_res) # results table with rows as genes (n = 6543)
head(diff_test_res)
```

All have status == "OK" and family == "negbinomial.size"
```{r}
diff_test_res %>%
  group_by(status, family) %>%
  summarize(n = length(gene_short_name))
```

Pull out DEG based on qval < 0.05. Use these genes to cluster/order cells. Notice that after applying setOrderingFilter(), the column "use_for_ordering" gets added to the featureData.
```{r}
diff_test_res %>%
  filter(qval < 0.05) -> deg.df

dim(diff_test_res)[1] # 6543 genes tested
dim(deg.df)[1] # 2763 DEGs

ordering_genes <- row.names(subset(diff_test_res, qval < 0.05))
cds.o <- setOrderingFilter(cds.exprs, ordering_genes)

head(fData(cds.o)) # now has the column "use_for_ordering"
```

Reduce data dimensionality using Discriminative Dimensionality Reduction with Trees (DDRTree). 

From reduceDimension() help: "Prior to reducing the dimensionality of the data, it usually helps to normalize it so that highly expressed or highly variable genes don't dominate the computation. The function reduceDimension() automatically transforms the data in one of several ways depending on the expressionFamily of the CellDataSet object. If the expressionFamily is negbinomial or negbinomial.size, the data are variance-stabilized." 

```{r}
#cds.rd <- reduceDimension(cds.o, max_components = 2, method = 'DDRTree')
# since this can take some time, I saved the resulting object `cds.rd` as an intermediate
#saveRDS(cds.rd, file.path(intermeddir, "cds-rd.RData"))

cds.rd <- readRDS(file.path(intermeddir, "cds-rd.RData"))
cds.rd
```

Notice that data generated by reduceDimensions() are stored inside the CellDataSet object
```{r}
dim(cds.rd@reducedDimS)[2] # 2779 columns, coordinates for each cell
cds.rd@reducedDimS[1:2,1:5] # rows correspond to the dimensions, i.e. here we set max_components to 2
```

Order cells along the trajectory. 

From orderCells() help: "Learns a "trajectory" describing the biological process the cells are going through, and calculates where each cell falls within that trajectory. ...This function takes as input a CellDataSet and returns it with two new columns: Pseudotime and State, which together encode where each cell maps to the trajectory in the reduced-dimension space. 

Notice that after applying orderCells(), the columns "Pseudotime" and "State" get added to the phenoData.
```{r}
# cds.oc <- orderCells(cds.rd)
# since this can take some time, I saved the resulting object `cds.oc` as an intermediate
#saveRDS(cds.oc, file.path(intermeddir, "cds-oc.RData"))

cds.oc <- readRDS(file.path(intermeddir, "cds-oc.RData"))
cds.oc

head(pData(cds.oc)) # now has the columns "Pseudotime" and "State"
```

Plot trajectory
```{r}
plot_cell_trajectory(cds.oc, color_by = "orig.ident")
```

## 4. Test for DE over psuedotime

Pull out all "Il" genes. Subset the CellDataSet to the "Il" genes.
```{r}
fData(cds.oc) %>%
  pull(gene_short_name) -> all.ordered.genes

marker_genes <- grep('^Il', all.ordered.genes, value = T)
marker_genes

cds.mg <- cds.oc[marker_genes,]
cds.mg
```

Test whether the expression of each gene varies with pseudotime. 

```{r}
diff_test_res2 <- differentialGeneTest(cds.mg, fullModelFormulaStr = "~sm.ns(Pseudotime)")
diff_test_res2
```


Notice how the model formula is specified. The term "Pseudotime" refers to the column in phenoData. 
```{r}
head(pData(cds.mg))
```

Then, `Pseudotime` is surrounded by the function `sm.ns()`, which is defined in the R package VGAM. 
It is a "smart" version of splines::ns() that specifies the model as a spline regression.
```{r}
?sm.ns()
?ns()
```

Select genes that are significant at an FDR < 5%
```{r}
diff_test_res2 %>%
  filter(qval < 0.05) -> sig_genes
sig_genes

cds.mg1 <- cds.mg[sig_genes$gene_short_name,]
cds.mg1
```

Plot individual genes
```{r}
plot_genes_in_pseudotime(cds.mg1, ncol=3)
```

## 5. Using Monocle3

Major updates in Monocle 3: https://cole-trapnell-lab.github.io/monocle3/docs/updates/

Most of the algorithmic details in Monocle 3 are described in Cao & Spielmann et al.
https://www.nature.com/articles/s41586-019-0969-x

The following is based on "Constructing Single-cell trajectories" http://cole-trapnell-lab.github.io/monocle-release/docs/#constructing-single-cell-trajectories"

```{r}
#detach(package:monocle,unload=TRUE)

library(monocle3)
package.version("monocle3")
```

### i. Create the data object

Notice that the cell_metadata and gene_metadata (formerly phenoData and featureData) no longer need to be in the AnnotatedDataFrame structure.

```{r}
# Monocle 2
# cds <- newCellDataSet(cellData = cd, 
#                       phenoData = pd.adf, 
#                       featureData = fd.adf)
#cds

# Monocle 3
cds.m3 <- new_cell_data_set(expression_data = cd,
                            cell_metadata = pd,
                            gene_metadata = fd)
cds.m3
```

### ii. Normalize and pre-process the data

The default pre-processing steps look very different. The monocle3 preprocessing default is to log-normalize and PCA to reduce the dimensions of the expression matrix. Filtering genes based on a detection threshold is not included.
```{r}
# Monocle 2
# cds.es <- estimateSizeFactors(cds)
# cds.ds <- estimateDispersions(cds.es)
# cds.filt <- detectGenes(cds.ds, min_expr = 0.1)
# fData(cds.filt) %>%
#   filter(num_cells_expressed >= 100) %>%
#   row.names() -> expressed_genes
# cds.exprs <- cds.filt[expressed_genes,] 

# Monocle 3
cds.m3.preproc <- preprocess_cds(cds.m3, 
                                 norm_method = "log",
                                 method = "PCA",
                                 num_dim = 100) 
```

### iii. Reduce the dimensions using UMAP.

Is DDRTree no longer recommended? It is not included in the list of "reduction_method" options.

```{r}
# Monocle 2
#cds.rd <- reduceDimension(cds.o, max_components = 2, method = 'DDRTree')

# Monocle 3
cds.m3.rd <- reduce_dimension(cds.m3.preproc,
                              reduction_method = "UMAP",
                              max_components = 2)
plot_cells(cds.m3.rd, color_cells_by = "orig.ident")
```

### iv. Cluster the cells

This step was not previously performed, correct?
```{r}
# Monocle 2
#??

# Monocle 3
cds.m3.cl <- cluster_cells(cds.m3.rd)
plot_cells(cds.m3.cl, color_cells_by = "partition")
```

### v. Learn a graph

This step was not explictly included in the previous procedure, correct?

Is use_partition=F necessary to have all cells included in the trajectory rather then fit trajectories by cluster?

```{r}
# Monocle 2
#??

# Monocle 3
cds.m3.lg <- learn_graph(cds.m3.cl, 
                         use_partition = F)
#When use_partition = FALSE, a single graph is learned across all partitions.
plot_cells(cds.m3.lg,
           color_cells_by = "orig.ident",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)
```

### vi. Order cells

In this version, we must indicate a root state to specify the start of the trajectory. How was this determined in monocle2?

```{r}
# Monocle 2
# cds.oc <- orderCells(cds.rd)

# Monocle 3
cds.m3.oc <- order_cells(cds.m3.lg,
                   reduction_method = "UMAP")
#  order_cells() optionally takes "root" state(s) in the form of cell or principal graph node IDs, which you can use to specify the start of the trajectory. If you don't provide a root state, an plot will be generated where you can choose the root state(s) interactively. The trajectory will be composed of segments.
plot_cells(cds.m3.oc,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)
```

From Monocle 3 tutorial: "It's often desirable to specify the root of the trajectory programmatically, rather than manually picking it. The function below does so by first grouping the cells according to which trajectory graph node they are nearest to. Then, it calculates what fraction of the cells at each node come from the earliest time point. Then it picks the node that is most heavily occupied by early cells and returns that as the root."

**I am not sure how this could be altered to reproduce the trajectory from monocle2 above without manually specifying the root**
```{r}
# a helper function to identify the root principal points:
get_earliest_principal_node <- function(cds, time_bin="130-170"){
  
  cell_ids <- which(colData(cds)[, "embryo.time.bin"] == time_bin)
  
  closest_vertex <-
  cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <-
  igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
  (which.max(table(closest_vertex[cell_ids,]))))]
  
  return(root_pr_nodes)
}
cds.m3.oc.pr <- order_cells(cds.m3.lg, root_pr_nodes=get_earliest_principal_node(cds.m3.lg))

```

### vii. Plot cell trajectory

```{r}
# Monocle 2
#plot_cell_trajectory(cds.oc, color_by = "orig.ident")

# Monocle 3
plot_cells(cds.m3.oc, color_cells_by = "orig.ident",   
           min_expr = 0.1)
```
### viii. Pull out Il genes

```{r}
# Monocle 2
# fData(cds.oc) %>%
#   pull(gene_short_name) -> all.ordered.genes
# marker_genes <- grep('^Il', all.ordered.genes, value = T)
# cds.mg <- cds.oc[marker_genes,]
# cds.mg


# Monocle 3
all.ordered.genes.m3 <- fData(cds.m3.oc)[,"gene_short_name"]
marker_genes.m3 <- grep('^Il', all.ordered.genes.m3, value = T)
cds.m3.mg <- cds.m3.oc[marker_genes.m3,]
cds.m3.mg
```

# ix. Examine how gene expression changes through pseudotime

```{r}
# Monocle 2
# diff_test_res2 <- differentialGeneTest(cds.mg, fullModelFormulaStr = "~sm.ns(Pseudotime)")
# diff_test_res2 %>%
#   filter(qval < 0.05) -> sig_genes
# sig_genes
# cds.mg1 <- cds.mg[sig_genes$gene_short_name,]
# cds.mg1
# plot_genes_in_pseudotime(cds.mg1, ncol=3)

# Monocle 3
# instead of regression use graph_test?
test_res <- graph_test(cds.m3.mg, neighbor_graph="principal_graph", cores=4)
test_res
pr_deg_ids <- row.names(subset(test_res, q_value < 0.05))
pr_deg_ids


row.sel <- rowData(cds.m3.mg)$gene_short_name %in% c("Il17f","Il1r2")
#colData(cds.m3.mg)
lineage_cds <- cds.m3.mg[row.sel,]
plot_genes_in_pseudotime(lineage_cds)
```
#Error in cds_subset@expressionFamily@vfamily %in% c("negbinomial", "negbinomial.size") : no slot of name "expressionFamily" for this object of class "cell_data_set"

